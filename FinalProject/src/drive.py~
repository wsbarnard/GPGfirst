#!/usr/bin/env python


#publishes a twist message t othe cmd_vel_mux/input/teleop topic
def publishTwist(speed, angSpeed):
    pub = rospy.Publisher('cmd_vel_mux/input/teleop', Twist, queue_size = 1)
    
    twist = Twist() 
    twist.linear.x = speed; twist.linear.y = 0; twist.linear.z = 0
    twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = angSpeed
    pub.publish(twist)

#This function accepts two wheel velocities and a time interval.
def spinWheels(u1, u2, t):
    r = 0.035 # wheel radius
    b = 0.23 # distance between wheels

    #calculates speed and angSpeed  
    speed = (r/2)*(u1 + u2)
    angSpeed = (r/b)*(u1 - u2)

    start = time.time()

    #publish until stop time
    while(time.time() - start < t):
        publishTwist(speed, angSpeed)

    publishTwist(0, 0) #stop when done

#This function accepts a speed and a distance for the robot to move in a straight line
def driveStraight(speed, dist):
    poleRate = .05
    tol = .2
    
    rospy.sleep(.5)

    # set the desired x y positions
    xGoal = x + dist * math.cos(theta) 
    yGoal = y + dist * math.sin(theta)

    #while not at goal 
    while((x < xGoal - tol or x > xGoal + tol) or 
            (y < yGoal - tol or y > yGoal + tol)):

        # keep driving forward
        publishTwist(speed, 0)
        #print "x %f" % (x)
        #print "y %f" % (y)

        # delay by poleRate
        rospy.sleep(poleRate)

    publishTwist(0, 0) # stop robot

#Accepts an angle and makes the robot rotate around it.
def rotate(angle):
    global theta
    poleRate = .1
    tol = .1
    
    time.sleep(.5)
    print angle

    # set desired theta, if user pases a theta > 2pi or < -2pi, 
    # angle is moduloed to make put it in range of -2pi to 2pi
    angGoal = theta + (angle%(2*math.pi))

    # constrain further to -pi to pi because odom range is -pi to pi
    if angGoal >= math.pi:
        angGoal -= (2*math.pi)

    if angGoal < -math.pi:
        angGoal += (2*math.pi)

    #while not at goal 
    while(theta < angGoal - tol or theta > angGoal + tol):
        #spin direction based on sign of input
        if angle >= 0:
            publishTwist(0, .4)
        else:
            publishTwist(0, -.4)
        
        #print "angGoal %f theta %f" % (angGoal, theta)

        time.sleep(poleRate)

    publishTwist(0, 0) # stop robot
